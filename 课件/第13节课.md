有两个问题：

1. 对于订单数据（订单有两个属性，一个是下单时间，另一个是订单金额），如何根据金额从小到大对订单数据排序，同时对于金额相同的订单，按照下单时间从早到晚有序。（假设下单时间和金额都是整形）



| 下单时间 | 金额 | ID   |
| -------- | ---- | ---- |
| 2018-9-8 | 60   | 1    |
| 2018-9-7 | 30   | 2    |
| 2018-9-4 | 30   | 3    |
| 2018-9-5 | 40   | 4    |
| 2018-9-6 | 30   | 5    |
| 2018-9-3 | 50   | 6    |

上节课我们讲了两次排序的思路，第一次按照下单时间排序，第二次用稳定排序法对金额排序。

如何在单次排序中解决？



假设我们用插入排序，我们定义这样的比较条件：

a) 当前订单的金额小于已排序区间中的订单金额，则触发元素的移动操作。

b) 当前订单的金额等于已排序区间中的订单金额时，如果当前订单的下单时间小于已排序区间中的下单时间，则触发元素的移动操作。

c) 其他情况不做移动操作。



待改造的代码：

```C++
// 插入排序，a表示数组，n表示数组大小
void insertionSort(int a[], int n) {
  if (n <= 1) return;
	// A[0, i-1] 这个区间是已排序区间，初始时这个区间里只有A[0]一个元素
  // A[i, n-1] 这个区间是未排序区间，初始时这个区间里有除了第一个元素之外的所有元素
  for (int i = 1; i < n; ++i) {
    int value = a[i];
    // 查找插入的位置
    int j = i - 1;
    for (; j >= 0; --j) {
      if (value < a[j]) { // 这里就是元素的比较操作，value是当前元素，a[j]代表已排序区间中的元素
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```



首先我们引入结构体来表示订单类型：

```c++
struct Order {
  int date;    //用20180908表示日期2018-9-8
  int money;   //订单金额
  int id;      //订单编号
};  //不要忘记这个分号

Order a[100]; //订单数组，包含100个元素。这里的Order就是一个自定义类型，本质上跟内置类型比如int没有区别。

//指定初始化
a[0].date = 20190908;
a[0].money = 60;
a[0].id = 1;

...
  
  
//赋值初始化
a[0] = {20190908, 60, 1};
a[1] = {20190907, 30, 2};
...

  
```



改造后的代码：

```C++
void insertionSort(Order a[], int n) {
    if (n <= 1) return;

    for (int i = 1; i < n; ++i) {
        Order cur = a[i];
        int j = i - 1;
        // 查找插入的位置
        for (; j >= 0; --j) {
            if ( cur.money < a[j].money || (cur.money == a[j].money && cur.date < a[j].date)) { // 这里就是元素的比较操作
                a[j+1] = a[j];  // 数据移动
            } else {
                break;
            }
        }
        a[j+1] = cur; // 插入数据
        
        printOrder(i, a, n);
    }
}

void printOrder(int round, Order a[], int n) {
    cout << "第" << round << "轮:" << endl;
    for (int i = 0; i < n; i++) {
        cout << a[i].date << " " << a[i].money << " " << a[i].id << endl;
    }
}

/*
第1轮:
20180907 30 2
20180908 60 1
20180904 30 3
20180905 40 4
20180906 30 5
20180903 50 6
第2轮:
20180904 30 3
20180907 30 2
20180908 60 1
20180905 40 4
20180906 30 5
20180903 50 6
第3轮:
20180904 30 3
20180907 30 2
20180905 40 4
20180908 60 1
20180906 30 5
20180903 50 6
第4轮:
20180904 30 3
20180906 30 5
20180907 30 2
20180905 40 4
20180908 60 1
20180903 50 6
第5轮:
20180904 30 3
20180906 30 5
20180907 30 2
20180905 40 4
20180903 50 6
20180908 60 1
*/
```



C++标准库里其实提供了两种通用的排序算法：

```C++
#include <algorithm>
sort(first, last, comp); //对半闭合区间 [first, last) 的元素进行排序，comp是自定义的比较函数
stable_sort(first, last, comp); //跟sort函数类似，但它是稳定排序
```



如何用标准库的排序算法改进：

```c++

bool mycomp(Order cur, Order o2) {
    if (cur.money < o2.money || (cur.money == o2.money && cur.date < o2.date)) return true;
    return false;
}

sort(a, a+6, mycomp);
```





2. 快速排序的最好情况是每次分区都是均等，最坏情况是每次分区后数据都集中在一个区间。假如每次分区都将数据分成9：1的两个区间，它的时间复杂度如何？

已知递推表达式：

```C++
T(1) = 1；   n=1时，只需要1的执行时间。

T(n) = T(n/10) + T(9*n/10) + n； n>1
```



我们可以用一颗递归树：

<img src="https://static001.geekbang.org/resource/image/44/43/44972a3531dae0b7a0ccc935bc13f243.jpg" alt="img" style="zoom:67%;" />



快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 n。我们现在只要求出递归树的高度 h，这个快排过程遍历的数据个数就是 h∗n ，也就是说，时间复杂度就是 O(h∗n)。



因为每次分区并不是均匀地一分为二，所以递归树并不是满二叉树。这样一个递归树的高度是多少呢？

我们知道，快速排序结束的条件就是待排序的小区间，大小为 1，也就是说叶子节点里的数据规模是 1。从根节点 n 到叶子节点 1，递归树中最短的一个路径每次都乘以$\frac{1}{10}$，最长的一个路径每次都乘以  $\frac{9}{10}$ 。通过计算，我们可以得到，从根节点到叶子节点的最短路径是 $\log_{10}n$，最长的路径是 $\log_{10/9}n$

 <img src="https://static001.geekbang.org/resource/image/7c/ed/7cea8607f0d92a901f3152341830d6ed.jpg" alt="img" style="zoom:50%;" />

所以，遍历数据的个数总和就介于 n$\log_{10}n$， 和 n $\log_{10/9}n$ 之间。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，我们统一写成nlog(n)，所以，当分区大小比例是 1:9 时，快速排序的时间复杂度仍然是 O(nlogn)。



### 思考

http://ybt.ssoier.cn:8088/problem_show.php?pid=1181